# 고급 백엔드 스터디 6주차 : B 트리 구현 (1)

**\# 페이지 헤더** 

: 페이지 헤더에는 탐색과 유지보수, 최적화에 필요한 페이지에 대한 정보가 저장된다.
 
</br>

**\# 매직 넘버**

: 파일 헤더나 페이지 헤더에 주로 저장되는 값으로, 페이지의 종류와 버전과 같은 정보를 포함한다. 

\- 매직 넘버 값을 통해 찾고자 하는 데이터를 식별할 수 있다. 

</br>

**\# 형제 링크**

: 같은 조상을 가진 형제 노드끼리 서로를 가리키는 포인터를 가지면, 빠르게 같은 레벨의 노드에 접근할 수 있다.

</br>

**\# 가장 오른쪽 포인터**

\- B 트리의 노드가 가지는 마지막 포인터는 키와 쌍을 이루지 않는다.

(B 트리의 모든 노드는 키의 개수보다 하나 더 많은 수의 포인터를 가지기 때문이다.)

\- 마지막 포인터를 헤더에 저장하도록 구현할 수 있다.

\- 자식 노드 분할 시, 부모의 마지막 포인터 업데이트

1) 자식 노드가 분할될 때, 자식 노드의 분할 지점의 키는 부모 노드로 **이동**하면서 승급된다.

2) 승급된 키는 기존의 자식 노드를 가리킨다. 

3) 부모의 마지막 포인터는 새로운 자식 노드를 가리킨다.


</br>

\*\* 부모 노드가 자식 노드를 하나씩 추가할 때마다, 부모 노드의 마지막 포인터는 새로운 자식 노드를 가리키도록 업데이트 된다. \*\* 

</br>

**\# 하이 키**

: 현재 노드의 서브트리에 저장된 가장 큰 키. 

\- **B-link 트리** : 각 노드에 하이키와 오른쪽 형제 노드 포인터를 같이 저장해 동시성을 개선한 변형 트리이다.

\- B link 트리의 각 노드에서 키의 개수와 포인터 개수는 동일하다. 

\- 하이키를 노드에 같이 저장하면, 한 노드가 담당하는 키의 상한이 정해지게 된다. 그렇게 되면 마지막 오른쪽 포인터가 담당하는 범위도 명확히 지정해줄 수 있게 되어서 에지 케이스가 줄어든다. 



```
# 에지 케이스 

: 일반적인 동작에서 벗어나는 예외적인 상황을 말한다. 
```
</br>


**\# 오버플로우 페이지**

\- B 트리 노드는 일정 개수의 키를 유지해야 하는 키 개수 규칙이 있지만, 개별 엔트리 크기의 차이 때문에 페이지가 물리적으로 먼저 가득 차면, 키 개수를 다 채우지 않았어도 페이지 분할이나 새로운 페이지 할당이 필요하다. 그렇게 새로 할당된 페이지를 **오버플로우 페이지** 라고 부른다. 

</br>

\- 오버플로우 페이지를 기존의 페이지(=기본 페이지)와 연결하면 페이지 크기를 늘리는 것과 같은 효과를 얻을 수 있다. 

\- 첫 번째 오버플로우 페이지의 ID는 기본 페이지의 헤더에, 추가적인 오버플로우 페이지의 ID는 바로 앞 오버플로우 페이지의 헤더에 저장된다. 이런식으로 기본페이지와 오버플로우 페이지들이 연결된다. 

</br>

\- 기본 페이지는 언제나 max\_payload\_byte 만큼의 빈 공간을 유지해야 하고, 그 공간이 부족해지면 일부 엔트리를 오버플로우 페이지에 옮기거나 페이지를 분할해 기본 페이지의 빈 공간을 다시 확보한다.

</br>

\- 기본 페이지의 각 레코드는 본인의 나머지 데이터가 있는 오버플로우 페이지를 가리킨다. (데이터가 나눠서 저장되는 경우)

</br>

\- 만약 모든 데이터의 사이즈가 크다면 blob 스토리지 등의 사용을 고려해야 한다. 

</br>


```
# Blob(Binary Large Object) 스토리지

\- 문자열, 숫자처럼 큰 바이너리 데이터를 테이블에 직접 다 저장하는 게 아니라 그 데이터는 따로 저장소에 두고,

테이블에는 그 데이터를 참조하는 포인터만 저장하는 방식이다. 

\- Blob 스토리지는 Blob 전용 저장소를 말한다. 
```
</br>


**\# 이진 검색** 

\- 이진 검색은 데이터가 정렬된 경우에만 유효하고, 따라서 키를 정렬된 상태로 유지하는 것은 중요하다. 

</br>

\- 이진 검색 알고리즘은 정렬된 배열과 검색 키를 인자로 받고 숫자를 반환한다. 반환된 숫자가 0 이상인 경우 이 숫자는 해당 키가 존재하는 배열 상의 위치를 나타내고, 음수라면 해당 키는 배열에 존재하지 않다는 의미이며 반환된 값의 절댓값은 배열의 삽입 위치가 된다. 

</br>

\- 삽입 위치는 검색 키보다 크거나 같은 첫 번째 값의 위치이다.

\- 삽입 시에는 삽입 위치 이후의 모든 원소를 한 자리씩 이동시켜 새로운 값을 위한 공간을 만들고 삽입한다. 
</br>

\- 상위 레벨에서 검색 키를 찾는 경우는 드물다.

\- 검색 키보다 큰 첫 번째 값을 찾고, 그 값의 배열상의 위치와 일치하는 포인터를 따라가는 것이 중요하다. 

예) 키 - \[10, 20, 30, 40\] | 검색 키 = 25(<30) ... 포인터 p2(30의 인덱스가 2니까) 따라가기

</br>

**\# 간접 포인터를 사용한 이진 검색**

\- B 트리 페이지의 셀은 삽입 순서대로 저장되고, 셀 포인터만 논리적 순서를 유지한다.

(즉, 셀 포인터는 키 값의 오름차순 정렬에 맞춰 저장된다.)

</br>

**\# 부모 포인터를 사용한 노드 순회**

\- 일부 트리 구현에서는 형제 포인터 사용으로 인해 발생할 수 있는 데드록을 제거하기 위해, 리프 노드 탐색에 부모 포인터를 사용하기도 한다. 

</br>

```
# deadlock 

: 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태.
```

</br>

**\# 탐색 경로**

\- **탐색 경로 테이블** : 루트부터 리프까지 내려가는 동안 방문한 노드와 각 노드에서 선택한 경로(인덱스, 포인터)를 기록하는 테이블.

\- 탐색 경로가 저장된 스택은 메모리에 저장된다. 

\- 노드의 분할과 병합 과정이 부모 노드에게까지 전파될 때, 탐색 경로 테이블을 보고 부모 노드를 찾아 부모 노드를 수정한다. 

\- 부모 노드를 저장해두지 않으면, 수정할 부모 노드를 다시 찾아야 하며 경우에 따라 루트 노드부터 재탐색이 필요할 수 있다. (비효율적)