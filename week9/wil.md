# 고급 백엔드 스터디 9주차

</br>

## **\# 복구**

트랜잭션 수행 과정에서 장애가 발생한 경우, 데이터 복구가 필요하다. 

이를 위한 기능이 WAL(선행 기록 로그, 커밋 로그) 이다. 
</br>

## **\# WAL(Write-Ahead Logging)**

: 장애 및 트랜잭션 복구를 위해 디스크에 저장하는 추가 전용 보조 자료 구조이다. 

\- WAL 을 사용하면 디스크에 데이터를 쓸 때 발생하는 물리적인 I/O 을 최적화할 수 있다. 

\- **페이지 캐시** : 디스크 파일의 데이터를 메모리에 임시 저장해 두는 공간으로, 읽기와 쓰기 모두 캐싱하며, 쓰기 변경사항은 디스크에 반영되기 전까지 메모리에 버퍼링된다.

</br>


**a. WAL 을 사용하지 않고 디스크 데이터 블럭에 데이터를 쓰는 경우**

1\. 데이터를 쓰고자 하는 디스크의 데이터 블럭을 메모리 버퍼에 가져온다. 

2\. 메모리 버퍼에 올라온 데이터 블럭에 데이터를 쓴다. (이때 메모리 버퍼에서 수정된 데이터를 더티 페이지(더티 블럭)라고 한다.)

3\. 메모리 버퍼에서 데이터가 쓰여진 데이터 블럭과 같은 디스크 블럭에 내용을 반영한다.

\--> 3. 의 단계에서 알맞은 디스크 블럭을 찾는데 시간이 소요된다. 

</br>

**b. WAL 을 사용하여 디스크 데이터 블럭에 데이터를 쓰는 경우**

 - WAL을 사용하면 변경 내용을 디스크 데이터 파일에 바로 쓰기 전에, 로그 버퍼에 순차적으로 변경 사항을 저장한다. 이후, 쌓인 변경 사항을 디스크 데이터 블럭에 한 번에 플러시할 수 있다.

\- 메모리 버퍼에서 데이터 블럭에 데이터를 쓸 때, 로그 버퍼에 트랜잭션 순으로 변경사항이 저장된다.

\- 로그 버퍼 에 쌓아 놓은 변경사항은 체크포인트 시점을 기준으로 디스크에 플러시된다.  

</br>


```
" WAL 을 사용하더라도 어차피 나중에 디스크로 데이터를 옮길 때는 알맞은 위치를 찾아야 하지 않나? "

" 그때 랜던 I/O 에 대한 시간이 발생하지 않나? "

라는 의문이 들었다. 

" WAL 이 쓰기 성능에 도움을 준다는 말이 곧, 디스크에 데이터를 빨리 써지도록 하는 게 아니다. 

체크포인트가 발생해서 디스크에 데이터가 써질 때 랜덤 I/O 이 발생하긴 하지만, 이 과정은 백그라운드에서 천천히 이루어지기도 하고 변경사항이 모아서 처리되기 때문에 트랜잭션의 일부라도 묶어서 처리할 수 있어 WAL이 쓰기 속도 향상에 영향을 준다. "

이렇게 답을 내렸다. 
```

---

</br>


## **\# WAL 로그의 순서**

\- WAL 의 모든 로그 레코드는 순서를 가진다. 

\- 단조 증가하는 고유한 **로그 시퀀스 번호(LSN, Log Sequence Number)** 가 로그 레코드의 순서를 정의한다.

\- 모든 레코드는 LSN 순서에 맞춰 디스크로 플러시된다. 

\- LSN 은 내부 카운터 값이거나 타임스탬프 값이다. 

</br>

## **\# 트랜잭션 커밋 레코드의 LSN**

\- WAL 은 작업 로그 레코드 이외에도 트랜잭션 완료 여부를 나타내는 레코드를 저장한다. 

\- 트랜잭션의 커밋 레코드의 LSN까지 플러시되기 전까지는, 해당 트랜잭션이 커밋되었다고 할 수 없다. 

</br>

## **\# 보상 로그 레코드 (CLR, Compensation Log Record)**

\- 일부 시스템은 트랜잭션 롤백 또는 복구 중 장애가 발생해도 시스템이 계속해서 정상 작동할 수 있도록 CLR 을 로그에 저장하고 undo 작업에 사용한다. 

\- undo 과정에서 수행된 변경을 WAL에 기록해 장애 복구 시 일관성을 유지한다.

</br> 

## **\# 체크포인트**

\- 체크포인트가 발생하면 해당 시점 이전의 모든 로그 레코드를 디스크로 플러시한다. 

\- **싱크**(sync)** 체크포인트** : 모든 더티 페이지를 강제로 디스크로 플러시 하는 작업.

</br>

</br>

모든 데이터를 한 번에 디스크로 플러시 할 때, 체크포인트 작업이 이루어지는 동안 다른 작업은 모두 중지되어야 한다. 

이런 비효율적인 방식을 해결하기 위해 나온 시스템이,

## **\# 퍼지(fuzzy) 체크포인트**

\- 퍼지 체크포인트는 체크포인트를 위한 로그 레코드를 기록함으로써 트랜잭션을 중단하지 않고 체크포인트 작업을 할 수 있게 해준다.  

\- 체크포인트를 추적하기 위한 로그 레코드로 

**1)** **begin\_checkpoint**

**2) end\_checkpoint  
**

를 사용한다. 

</br>

\- begin\_checkpoint 는 체크포인트 시작을 알리는 로그 레코드이다.

\- begin\_checkpoint 레코드가 기록된 시점부터 플러시할 더티 페이지의 리스트와 트랜잭션 수행 정보를 수집한다. 

(여기서 트랜잭션 수행 정보란 플러시 도중 일어나는 트랜잭션과 플러시 이전에 진행중이던 트랜잭션에 대한 정보를 의미한다.)

\- 정보 수집 동안부터 더티 페이지 플러시는 진행된다.

\- end\_checkpoint 는 플러시해야 할 더티 페이지 리스트와 begin\_checkpoint 부터 end\_checkpoint 까지 일어난 트랜잭션의 리스트(플러시 하는 도중 발생한 플러시 해야할 정보)를 저장하는 시점이다. 

\- end\_checkpoint 로그가 기록되었다고 해서 플러시가 끝난 것이 아니다. end\_checkpoint 이후에도 플러시는 계속 일어난다.

\- 모든 더티 페이지의 플러시가 완료된면 last\_checkpoint 레코드의 LSN은 end\_checkpoint 의 LSN 으로 갱신된다.

\- 플러시 도중 장애가 발생하면, last\_checkpoint 레코드의 LSN 부터 redo를 다시 적용한다. 

</br>

## **\# 작업 로그 대 데이터 로그**

\- 작업 로그 -> **논리적 로그**: 수행한 작업에 대한 논리적인 기록. (무엇을 어떻게 변경했는지)

\- 데이터 로그 -> **물리적 로그** : 수행한 작업에 대한 실제 변경 내용을 기록. (논리적 로그대로 수행한 결과에 대한 기록)

</br>

\- undo 작업에는 논리적 로그를 사용하고, redo 작업에는 물리적 로그를 사용한다. 

이유)

\- undo 작업은 보통 트랜잭션이 이루어지고 있을 때 필요하다. 때문에 다른 트랜잭션이 동시에 undo 하고자 하는 페이지에 접근할 수 있다. 이런 이유로 값 자체를 변경하는 물리적 로그보다는 작업의 반대 연산을 수행하는 논리적 로그가 필요하다. 

\- redo 작업은 속도가 중요하다. '이렇게 해서 이렇게 값을 변경하라.' 식의 논리적 로그보다, '이 값을 이걸로 변경하라.' 식의 물리적 로그가 빠른 복구에 도움이 된다.