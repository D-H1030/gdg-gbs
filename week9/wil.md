# 고급 백엔드 스터디 9주차

</br>

## **\# 복구**

트랜잭션 수행 과정에서 장애가 발생한 경우, 데이터 복구가 필요하다. 

이를 위한 기능이 WAL(선행 기록 로그, 커밋 로그) 이다. 
</br>

## **\# WAL(Write-Ahead Logging)**

: 장애 및 트랜잭션 복구를 위해 디스크에 저장하는 추가 전용 보조 자료 구조이다. 

\- WAL 을 사용하면 디스크에 데이터를 쓸 때 발생하는 물리적인 I/O 을 최적화할 수 있다. 

\- **페이지 캐시** : 디스크 파일의 데이터를 메모리에 임시 저장해 두는 공간으로, 읽기와 쓰기 모두 캐싱하며, 쓰기 변경사항은 디스크에 반영되기 전까지 메모리에 버퍼링된다.

</br>


**a. WAL 을 사용하지 않고 디스크 데이터 블럭에 데이터를 쓰는 경우**

1\. 데이터를 쓰고자 하는 디스크의 데이터 블럭을 메모리 버퍼에 가져온다. 

2\. 메모리 버퍼에 올라온 데이터 블럭에 데이터를 쓴다. (이때 메모리 버퍼에서 수정된 데이터를 더티 페이지(더티 블럭)라고 한다.)

3\. 메모리 버퍼에서 데이터가 쓰여진 데이터 블럭과 같은 디스크 블럭에 내용을 반영한다.

\--> 3. 의 단계에서 알맞은 디스크 블럭을 찾는데 시간이 소요된다. 

</br>

**b. WAL 을 사용하여 디스크 데이터 블럭에 데이터를 쓰는 경우**

 - WAL을 사용하면 변경 내용을 디스크 데이터 파일에 바로 쓰기 전에, 로그 버퍼에 순차적으로 변경 사항을 저장한다. 이후, 쌓인 변경 사항을 디스크 데이터 블럭에 한 번에 플러시할 수 있다.

\- 메모리 버퍼에서 데이터 블럭에 데이터를 쓸 때, 로그 버퍼에 트랜잭션 순으로 변경사항이 저장된다.

\- 로그 버퍼 에 쌓아 놓은 변경사항은 체크포인트 시점을 기준으로 디스크에 플러시된다.  

</br>


```
" WAL 을 사용하더라도 어차피 나중에 디스크로 데이터를 옮길 때는 알맞은 위치를 찾아야 하지 않나? "

" 그때 랜던 I/O 에 대한 시간이 발생하지 않나? "

라는 의문이 들었다. 

" WAL 이 쓰기 성능에 도움을 준다는 말이 곧, 디스크에 데이터를 빨리 써지도록 하는 게 아니다. 

체크포인트가 발생해서 디스크에 데이터가 써질 때 랜덤 I/O 이 발생하긴 하지만, 이 과정은 백그라운드에서 천천히 이루어지기도 하고 변경사항이 모아서 처리되기 때문에 트랜잭션의 일부라도 묶어서 처리할 수 있어 WAL이 쓰기 속도 향상에 영향을 준다. "

이렇게 답을 내렸다. 
```

---

</br>


## **\# WAL 로그의 순서**

\- WAL 의 모든 로그 레코드는 순서를 가진다. 

\- 단조 증가하는 고유한 **로그 시퀀스 번호(LSN, Log Sequence Number)** 가 로그 레코드의 순서를 정의한다.

\- 모든 레코드는 LSN 순서에 맞춰 디스크로 플러시된다. 

\- LSN 은 내부 카운터 값이거나 타임스탬프 값이다. 

</br>

## **\# 트랜잭션 커밋 레코드의 LSN**

\- WAL 은 작업 로그 레코드 이외에도 트랜잭션 완료 여부를 나타내는 레코드를 저장한다. 

\- 트랜잭션의 커밋 레코드의 LSN까지 플러시되기 전까지는, 해당 트랜잭션이 커밋되었다고 할 수 없다. 

</br>

## **\# 보상 로그 레코드 (CLR, Compensation Log Record)**

\- 일부 시스템은 트랜잭션 롤백 또는 복구 중 장애가 발생해도 시스템이 계속해서 정상 작동할 수 있도록 CLR 을 로그에 저장하고 undo 작업에 사용한다. 

\- undo 과정에서 수행된 변경을 WAL에 기록해 장애 복구 시 일관성을 유지한다.

</br> 

## **\# 체크포인트**

\- 체크포인트가 발생하면 해당 시점 이전의 모든 로그 레코드를 디스크로 플러시한다. 

\- **싱크**(sync)** 체크포인트** : 모든 더티 페이지를 강제로 디스크로 플러시 하는 작업.

</br>

</br>

모든 데이터를 한 번에 디스크로 플러시 할 때, 체크포인트 작업이 이루어지는 동안 다른 작업은 모두 중지되어야 한다. 

이런 비효율적인 방식을 해결하기 위해 나온 시스템이,

## **\# 퍼지(fuzzy) 체크포인트**

\- 퍼지 체크포인트는 체크포인트를 위한 로그 레코드를 기록함으로써 트랜잭션을 중단하지 않고 체크포인트 작업을 할 수 있게 해준다.  

\- 체크포인트를 추적하기 위한 로그 레코드로 

**1)** **begin\_checkpoint**

**2) end\_checkpoint  
**

를 사용한다. 

</br>

\- begin\_checkpoint 는 체크포인트 시작을 알리는 로그 레코드이다.

\- begin\_checkpoint 레코드가 기록된 시점부터 플러시할 더티 페이지의 리스트와 트랜잭션 수행 정보를 수집한다. 

(여기서 트랜잭션 수행 정보란 플러시 도중 일어나는 트랜잭션과 플러시 이전에 진행중이던 트랜잭션에 대한 정보를 의미한다.)

\- 정보 수집 동안부터 더티 페이지 플러시는 진행된다.

\- end\_checkpoint 는 플러시해야 할 더티 페이지 리스트와 begin\_checkpoint 부터 end\_checkpoint 까지 일어난 트랜잭션의 리스트(플러시 하는 도중 발생한 플러시 해야할 정보)를 저장하는 시점이다. 

\- end\_checkpoint 로그가 기록되었다고 해서 플러시가 끝난 것이 아니다. end\_checkpoint 이후에도 플러시는 계속 일어난다.

\- 모든 더티 페이지의 플러시가 완료된면 last\_checkpoint 레코드의 LSN은 end\_checkpoint 의 LSN 으로 갱신된다.

\- 플러시 도중 장애가 발생하면, last\_checkpoint 레코드의 LSN 부터 redo를 다시 적용한다. 

</br>

## **\# 작업 로그 대 데이터 로그**

\- 작업 로그 -> **논리적 로그**: 수행한 작업에 대한 논리적인 기록. (무엇을 어떻게 변경했는지)

\- 데이터 로그 -> **물리적 로그** : 수행한 작업에 대한 실제 변경 내용을 기록. (논리적 로그대로 수행한 결과에 대한 기록)

</br>

\- undo 작업에는 논리적 로그를 사용하고, redo 작업에는 물리적 로그를 사용한다. 

이유)

\- undo 작업은 보통 트랜잭션이 이루어지고 있을 때 필요하다. 때문에 다른 트랜잭션이 동시에 undo 하고자 하는 페이지에 접근할 수 있다. 이런 이유로 값 자체를 변경하는 물리적 로그보다는 작업의 반대 연산을 수행하는 논리적 로그가 필요하다. 

\- redo 작업은 속도가 중요하다. '이렇게 해서 이렇게 값을 변경하라.' 식의 논리적 로그보다, '이 값을 이걸로 변경하라.' 식의 물리적 로그가 빠른 복구에 도움이 된다.

</br>

## **\# steal/no-steal 정책과 force/no-force 정책**

\- 메모리에 캐시된 변경 사항을 디스크로 플러시하는 시점을 결정하는 정책들.

\- 복구 알고리즘 선택에 큰 영향을 미친다. 

</br>

\<steal vs. no-steal>

\- **steal 정책** : 커밋 전 플러시 허용. 장애 발생 시, undo 를 해야 하지만 메모리에 있는 더티 페이지를 줄일 수 있다. 

\- **no-steal 정책** : 커밋 전 플러시 금지. 장애 발생 시, WAL에 의해 기록된 것만 redo 를 통해 복구. 

\- "더티 페이지를 스틸한다." : 더티 페이지를 디스크로 플러시하고, 새 페이지를 페이징하는 것.

</br>

\<force vs. no-force>

\- **force 정책** : 더티 페이지를 디스크에 플러시 해야만 커밋이 완료되는 것으로 본다. 장애가 발생해도 redo 작업이 필요하지 않다. 하지만 변경 후 플러시까지 해야 커밋이 되므로 커밋 속도가 느리다. 

\- **no-force 정책** : 더티 페이지를 디스크에 플러시하지 않아도 커밋이 완료되는 것으로 본다. 커밋이 되었지만 디스크에 기록되지 않은 트랜잭션이 있는 경우 redo 가 필요하다. 큰 캐시가 필요하다. 

\- "더티 페이지를 포스한다." : 커밋 전 플러시하는 것.

</br>

\*\* 트랜잭션의 원자성(Atomicity) 때문에 장애 발생으로 복구가 필요한 경우, 디스크에 존재하는 커밋되지 않은 내용은 반드시 undo 로 되돌려야 한다. \*\*

</br>

\*\* 커밋된 트랜잭션 -> redo / 미커밋 트랜잭션 -> undo \*\*

</br>


```
# 복구 시, 디스크에 최신 변경 사항이 저장되어 있는지를 확인하는 방법

"커밋은 되었지만 디스크에 기록되지 않은 트랜잭션이 있는 경우..." 

이런 경우를 어떻게 판단하는지가 궁금해서 찾아보았다. 

모든 로그 레코드에는 고유한 번호인 LSN 이 붙어있다.

각 페이지에는 PageLSN 이라는 메타데이터가 존재하는데, 이는 해당 페이지에 반영된 마지막 로그의 LSN 을 의미한다. 

<복구 과정>

1\. 로그에서 모든 트랜잭션들(커밋+미커밋)의 로그 레코드를 조사한다.

2\. 각 로그 레코드의 LSN을 확인한다. 

3\. 페이지의 PageLSN 과 로그 레코드들의 LSN 을 비교한다. 

만약 PageLSN < 로그 레코드 LSN 이면, 해당 페이지는 최신 변경 사항이 적용되지 않은 상태이므로 redo 를 수행한다.

만약 PageLSN >= 로그 레코드 LSN 이면, 해당 페이지는 최신 상태이다.
```
</br>

## **\# ARIES (복구 정책)**

\- Algorithms for Recovery and Isolation Exploiting Semantics

\- steal + no-force 지원

\- 물리적 redo, 논리적 undo, 퍼지 체크포인트 사용

\- 복구 단계

1\. 분석 단계 : 장애 발생 당시 캐시에 저장되어 있던 더티 페이지와 수행 중이던 트랜잭션을 파악한다. 

2\. redo 단계 : 장애가 발생하기 전까지의 작업을 재수행하여 데이터베이스를 이전 상태로 복원한다. 

3\. undo 단계 : 장애 시점에 완료되지 않은 트랜잭션을 롤백하고, 데이터베이스를 마지막 상태로 복원한다. 모든 작업은 실제 수행 순서의 역순으로 롤백된다. 보상 로그 레코드를 기록하여 동일한 undo 가 반복되지 않도록 한다. 

</br>

## **\# 동시성 제어**

: 동시에 수행되는 여러 트랜잭션 사이의 상호작용을 제어하는 것.

\- 동시성 제어의 목표는 동시에 수행 가능한 트랜잭션의 수를 최대화하면서도 데이터 무결성을 유지하는 것이다. 

</br>


**1)** **낙관적 동시성 제어 (OCC, Optimistic Concurrency Control)**

\- 여러 트랜잭션 사이의 충돌이 없을 것이라고 가정 -> '낙관적'

\- 여러 트랜잭션이 데이터를 동시에 읽고 쓰는 것을 허용하고 트랜잭션이 수행된 결과가 직렬화가 가능한지 여부를 결정한다. 

\- 커밋 전 충돌 여부를 확인하고, 충돌이 감지되면 충돌한 대상 중 하나를 버린다. 



```
# 동시성 제어에서의 직렬화

: 작업의 결과가, 어떤 순서로 하나씩 차례대로 실행한 것의 결과와 동일한지의 여부. 동일하다면 해당 작업은 직렬화 가능한 것.

**데이터 직렬화(데이터 표현 및 저장/전송을 위해 데이터를 바이트 스트림으로 변환하는 것)와는 다른 개념**
```
</br>

**2) 비관적(보수적) 동시성 제어 (PCC, Pessimistic(Conservative) Concurrency Control)**

\- 트랜잭션 사이의 충돌이 있을 것이라고 가정 -> '비관적'

**\- 잠금 기반 방식** : 각 트랜잭션은 동일한 레코드를 다른 트랜잭션이 접근할 수 없도록 레코드에 대한 잠금을 가진다. 

**\- 무잠금 방식** : 읽기와 쓰기에 대한 목록을 유지하고, 완료되지 않은 트랜잭션의 스케줄에 따라 다른 트랜잭션의 수행을 제한한다. 

</br>

**3) 다중 버전 동시성 제어 (MVCC, Multiversion Concurrency Control)**

\- 원본 데이터의 스냅샷을 저장하면서, 그 데이터를 변경한 새로운 레코드를 함께 저장한다. 

\- 데이터 변경마다 새로운 버전의 데이터가 생기는 것이다. 

\- 새로운 사용자가 데이터 변경을 원하면 원본 데이터의 스냅샷을 읽게 되고, 데이터를 변경한다. 

\- 데이터 변경을 취소하면 변경 이전의 버전을 기반으로 데이터를 복구한다. 

\- 성공적으로 데이터가 변경되면 변경 사항을 디스크에 반영한다. 

</br>

\- 잠금을 사용하지 않기 때문에 빠른 동작이 가능하다. 

\- 하지만 버전끼리의 충돌이 발생할 수 있으므로 애플리케이션 영역에서의 해결이 필요하다. 

\- 여러 버전의 데이터를 저장하기 위한 별도의 시스템이 필요하다.

</br> 

## **\# 직렬화 가능성**

\- **스케줄** : 트랜잭션을 수행하는데 필요한 작업 (읽기, 쓰기, 커밋, 중단 등의 데이터베이스 상태를 변경하는 작업) 의 목록이다. 

\- 스케줄에 포함되지 않는 작업들은 데이터베이스의 상태에 영향을 주지 않는다고 가정한다. (부작용이 없다.)

</br>

\- ACID 속성과 트랜잭션 결과의 정확성이 보장되는 경우, 작업의 병렬 수행이나 수행 순서 변경이 허용된다. (이 경우의 스케줄을 올바른 스케줄이라고 책에서는 표현하였다.)

\- **직렬 스케줄(Serial schedule)** : 트랜잭션을 한 번에 하나씩 순차적으로, 독립적으로 실행하는 스케줄. 성능 저하 문제가 존재한다. 

\- **직렬화 가능한 스케줄 (Serializable Schedule)** : 트랜잭션이 동시에 수행되더라도, 어떤 직렬 스케줄과 결과가 같아지는 스케줄.

</br>

## **\# 트랜잭션 격리**

**\- 격리 수준 (isolation level)** : 트랜잭션이 변경한 내용 중 어떤 부분이 언제 다른 트랜잭션에 의해 접근될 수 있는지에 대한 정의.

\- 트랜잭션을 격리시킴으로써 추가 비용이 발생하고 성능 저하의 요인이 될 수 있다. 

</br>

## **\# 읽기와 쓰기 이상 현상** 

\- 트랜잭션 사이의 완전한 격리성을 위한다면 성능 저하가 발생할 수 있다.

\- 약간의 격리성을 포기하여 성능을 높일 수 있는데 이때 여러 이상 현상이 발생할 수 있다. 

</br>


\- **읽기 이상 현상** 

**1) 더티 읽기 (dirty read)** : 아직 커밋되지 않은 다른 트랜잭션의 결과를 읽는 현상. 

**2) 반복 불가능 읽기 (또는 퍼지 읽기) (non-repeatable read, fuzzy read)** : 하나의 트랜잭션이 **동일한 로우**를 두 번 쿼리했을 때 두 **결과의** **값**이 서로 다른 현상. (두 번째 쿼리에서 로우를 읽기 전에 다른 트랜잭션이 해당 로우를 수정하고 커밋한 경우 발생할 수 있다.)

**3) 팬텀 읽기 (phantom read)** : 두 번의 **범위 쿼리** 시 두 **결과의 개수**가 다른 현상. 

\*\* 범위 쿼리 : 특정 데이터 레코드가 아닌 **일정 범위**의 레코드를 조회하는 쿼리 \*\* 

</br>

**\- 쓰기 이상 현상** 

**1) 갱신 분실 (lost update)** : 서로 다른 트랜잭션이 동일한 값을 수정하려 할 때, 먼저 그 값을 수정하고 커밋한 트랜잭션의 결과가 이후의 트랜잭션 결과에 의해 덮어씌워지는 것. 

**2) 더티 쓰기 (dirty read)** : 트랜잭션이 커밋되지 않은 더티 값을 읽고, 수정하고, 커밋하는 현상. 

**3) 쓰기 치우침 (write skew)** : 개별적인 트랜잭션의 수행 시에는 조건을 만족하지만, 동시에 여러 트랜잭션이 수행되는 경우에는 조건을 위반하게 되는 현상. 

</br>

## **\# 격리 수준**

: 어느 수준에서 격리성을 희생할 것인지에 대한 정의 

\- **가장 약한 격리 수준 : Read Uncommitted (커밋 전 읽기 허용)** : 더티 읽기, 반복 불가능 읽기, 팬텀 읽기가 발생할 수 있다. 

\- **Read committed(커밋 후 읽기 허용) :** 반복 불가능 읽기와 팬텀 읽기는 발생할 수 있다. 

\- 반복 불가능 읽기까지 허용하지 않으면 **repeatable read (반복 가능 읽기)**수준이 된다. 

</br>

\- **가장 강한 격리 수준 : 직렬화 가능(Serializable) 수준** : 어떤 읽기 이상 현상도 발생하지 않는다. 

</br>


\- **스냅샷 격리 (snapshot isolation)**

: 각 트랜잭션은 작업 시작 전 자신의 스냅샷을 저장한다. 이는 각 트랜잭션의 읽기/쓰기의 대상이 된다. 

: 커밋 전에 본인과 동일한 값을 변경한 트랜잭션이 없는지 확인하고(충돌 발생 여부 확인), 없었다면 커밋한다.

: 만약 처음 값에서 값이 변경되었다면, 롤백한다. 

: 먼저 커밋된 트랜잭션의 결과만 인정하고, 동일한 데이터를 갱신하려는 이후에 커밋된 트랜잭션은 롤백되는 것이다. 따라서 lost update 는 발생하지 않는다. 

: 두 개의 트랜잭션이 각자의 스냅샷에서 값을 읽고 수정한 결과가 조건을 위반하지 않는다면 모두의 커밋이 허용된다. 때문에 쓰기 치우침이 발생할 수 있다. 