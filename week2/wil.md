# 고급 백엔드 스터디 2주차

# \# column 형 DBMS 와 row 형 DBMS
: 데이터를 저장하는 방식에 따른 분류

1. column 형 : 같은 열에 속하는 값들을 함께 저장하는 방식
- 열별로 데이터를 묶어서 저장한다.
- 필요한 열의 값만 읽을 수 있어, 불필요한 디스크의 I/O를 줄일 수 있다.
- 조인과 필터링, 다중 로우 집계 등을 위해 튜플을 재구성할 때, 각 칼럼에 저장된 값들이 어떤 사용자(즉, 행)의 값인지 구분하기 위한 식별자가 필요하다. 이 경우 열의 데이터마다 식별자를 붙이게 되니까, 동일한 식별자가 각 열의 데이터에 중복해서 저장되게 되고 그 결과 데이터 양이 증가한다.
- 가상 식별자를 저장하고(예를 들어, 암묵적인 순서), 값의 위치를 기반으로 튜플을 재구성하기도 한다. 이 경우에는 데이터의 순서가 바뀌는 경우에는 튜플을 재구성할 수 없다.

> ### \# 튜플 재구성
> : 열 단위로 저장해 둔 값들을 나중에 같은 행으로 다시 모아주는 작업을 말한다.

- 같은 열의 값을 한 번에 읽으면 캐시 활용도와 처리 효율성이 높아진다.
- 최신 CPU 는 벡터 연산을 통해 한 번의 CPU 명령어로 많은 데이터를 처리할 수 있다.

> ### \# SIMD(Single Instruction Multiple Data) 명령어
> : 하나의 명령어로 여러 데이터를 동시에 처리할 수 있다.

- 자료형별로 데이터를 저장하면 압축률이 증가하고(데이터 압축률은 중복패턴이 많을수록 증가한다), 다양한 압축 알고리즘 중에서 해당 자료형에 가장 효과적인 기법을 선택할 수도 있다.

2. row 형 : 같은 행에 속하는 값들을 함께 저장하는 방식
- 하나의 레코드에 모든 필드의 값들이 들어있다. 모든 레코드의 구성 필드는 동일하다.
- 행 단위로 데이터를 저장하면 공간 지역성을 극대화할 수 있다. (보통 특정 사용자의 여러 필드가 함께 요청되는 경우가 많기 때문이다)
- 여러 사용자의 특정 필드를 읽을 때는 비효율적이다.
- 대부분의 전통적인 관계형 데이터베이스는 row 형 DBMS 이다.

** 어떤 방식의 데이터 접근이 빈번한지를 판단하여 적합한 저장 방식을 선택하는 것이 옳다. **

---

# \# 와이드 칼럼 스토어
- 한 행은 row 키로 구분되고, 그 행 안에 여러 칼럼이 있으며 관련있는 칼럼들은 칼럼 패밀리로 묶인다.
- row 키, 칼럼 패밀리, 칼럼 이름 세 개의 조합이 하나의 셀을 정확히 지정한다.
- 스키마가 고정적이지 않아서 각 행에 저장되는 칼럼의 수는 다를 수 있고, 칼럼 패밀리에 새 칼럼을 추가할 수 있다. 새로운 칼럼을 추가해도 테이블을 재구성하지 않아도 된다.
- 데이터를 row 키 범위로 분산 저장하고, 칼럼 패밀리 단위로 압축, 버전 관리, TTL 설정 등이 가능하다.

</br>

---

데이터 베이스 시스템은 데이터 레코드를 테이블 형식으로 저장하고, 일반적으로 각 테이블을 별도의 파일에 저장한다.</br>
데이터 베이스 시스템은 데이터 파일과 인덱스 파일을 분리한다.</br>
데이터 파일에는 데이터 레코드가 저장되고, 인덱스 파일에는 데이터 파일에서 레코드를 찾기 위한 메타데이터가 저장된다.

</br>

# \# 데이터 파일(primary file)
### 종류
1) 인덱스 구조형 테이블(IOT, Index - Organized Table)
- 실제 데이터 레코드를 인덱스와 함께 저장한다.
- 데이터는 키 순서대로 정렬된다.
- 찾으려는 데이터의 인덱스 값만 검색하면 바로 데이터를 얻을 수 있기 때문에 디스크 탐색 횟수를 최소 1회 줄일 수 있다.

2) 힙 구조형 테이블 (힙 파일)
- 삽입 순서대로 레코드를 저장한다.
- 데이터 검색 시 인덱스가 필요하다.

3) 해시 구조형 테이블 (해시 파일)
- 레코드를 각 키의 해시 값에 해당하는 버킷에 저장한다
- 버킷 내의 레코드는 보통 삽입 순서대로 저장되고, 일부 구현에서는 키 순서로 정렬하여 저장하기도 한다.

---

# \# 인덱스 파일
- 데이터 파일에 대한 인덱스를 'primary index(기본인덱스)' 라고 하고, 이외의 다른 인덱스는 'secondary index(보조인덱스)' 라고 한다.
- 프라이머리 인덱스는 하나의 레코드만 가리키지만 보조 인덱스는 그렇지 않다. 보조 인덱스 하나는 여러 레코드를 가리킬 수 있다.

- clustered index(클러스터형 인덱스) : 데이터 레코드의 정렬 순서와 검색 키의 정렬 순서가 같은 인덱스. 이 경우 데이터 레코드는 인덱스 파일이나 클러스터형 파일에 정렬되어 저장된다. 인덱스 구조형 테이블은 클러스터형 인덱스를 가진다.
- unclustered index(비클러스터형 인덱스) : 인덱스 키를 기준으로 정렬되지 않은 인덱스. 이 경우 데이터 레코드는 인덱스와 다른 파일에 저장된다.
- 기본 인덱스는 대부분 클러스터형 인덱스이고, 보조 인덱스는 비클러스터형 인덱스이다.

---

# \# 데이터 레코드 접근 방식
1) 데이터 레코드 직접 참조(파일 오프셋 사용) : 디스크 탐색 오버헤드는 줄지만, 레코드를 갱신하거나 위치를 변경할 때 포인터를 수정해야 하는 오버헤드가 발생한다.
2) 기본 인덱스를 통한 간접 참조 : 보조 인덱스에서 키를 찾고 그 키로 찾은 기본 인덱스를 통해 데이터 레코드를 참조한다. 디스크 탐색 오버헤드가 발생한다.
3) 두 가지 방식의 혼용 : 인덱스 파일에 데이터 파일 오프셋과 기본 키를 모두 저장하고 데이터 레코드를 참조할 때, 오프셋의 유효 여부를 먼저 확인한다. 만약 현재 오프셋이 유효하지 않은 경우(예를 들어, 데이터 레코드의 위치가 변경된 경우), 기본 키 인덱스를 통해 데이터를 간접 참조하고 새로운 오프셋을 저장한다.

---

# \# 데이터베이스 자료 구조의 고려 사항
1) 버퍼링 : 데이터를 디스크에 쓰기 전에 일부를 메모리에 저장하는 것.
2) 가변성과 불변성 : 파일 일부를 읽고 갱신한 뒤, 동일한 자리에 다시 쓸지에 대한 여부.
3) 순서화 : 디스크 페이지에 데이터 레코드를 키 순서대로 저장할지의 여부.
