# 고급 백엔드 스터디 7주차

## **\# 리밸런싱**
​
: 더 차있는 노드에서 덜 차있는 노드로 원소를 이동시키는 방법.

​
\- 노드의 점유율을 높이고, 트리의 높이를 낮추기 위해 리밸런싱을 한다.

​
\- 로드 밸런싱 : 노드의 삭제 대신 형제 노드로부터 원소를 가져와서 노드의 절반 이상이 원소로 차 있도록 유지하는 방식/ 노드의 분할 대신 형제 노드에게 원소를 보내는 방식

</br>

​
## **\# 오른쪽 추가 기법**
​
\- 기본 인덱스 키를 자동 증가 값으로 하여 모든 삽입이 가장 오른쪽 리프 노드에서만 일어나도록 한다. 

​
\- 노드의 분할이 가장 오른쪽 리프 노드에서만 일어난다. 

​
\- 최적화에 적합한 구조이다. 

</br>

​
\- PostgreSQL 의 패스트패스(fastpath) 방식
​
: 삽입하는 키가 트리의 가장 오른쪽 리프 노드의 첫번째 키보다 크고, 가장 오른쪽 리프 노드의 공간이 충분하다면 탐색과정을 생략하고 가장 오른쪽 리프 노드의 올바른 자리에 새로운 키를 삽입한다. (자동 증가 키를 사용하는 경우, 새로운 키가 항상 가장 큰 값이 되므로 B+ 트리 탐색을 생략하고, 가장 오른쪽 리프 노드의 마지막 자리에 바로 삽입할 수 있다.)

</br>
​
\- SQLite 의 퀵밸런스(quickbalance) 방식
​
: 트리의 가장 오른쪽 리프 노드가 공간이 가득 찬 경우, 새 키를 삽입할 때 가장 오른쪽 리프 노드를 하나 추가하여 거기에 삽입한다. 그리고 새 노드를 가리키도록 부모 노드의 포인터를 추가한다. 

​
\- 현재는 공간이 많이 비어있는 노드지만, 이후에 채워질 가능성이 매우 높다.
​

\- 장기적으로 봤을 때 원소의 삽입 시간이 줄어든다. 
​
</br>

## **\# 벌크 로딩**
​
: 대량의 데이터를 한 번에 데이터베이스에 삽입하는 것.

​
\- 대량의 데이터를 페이지에 기록하고, 해당 페이지의 첫번째 키를 부모 노드에게 전달한다. 이 키는 부모 노드의 구분키가 된다. 

​
\- 대량의 데이터를 페이지에 기록하게 되면, 페이지의 가장 첫번째 키들도 정렬된 상태가 된다. 

​
\- 키가 정렬된 상태에서 페이지를 채우므로, 각 리프 페이지의 키들도 정렬되며, 이를 기반으로 내부 노드가 구성된다.

​
\- 벌크로딩 이후에는 일반적인 B+ 트리의 삽입 로직을 통해 정렬된 순서가 유지되며 새로운 데이터가 삽입된다.
​

</br>


## **\# 압축**
​
\- 원시 데이터를 압축하지 않고 저장하면 저장 오버헤드가 발생할 수 있어 압축이 필요하다. 

​
\- 파일 전체 압축하기

​
\- 페이지 단위로 압축하기

​
\- 레코드(행) 단위 칼럼 단위로 압축하기 : 이 경우 페이지 관리와 압축 작업이 분리되어 수행된다.

</br>

​
\- 일반적으로 압축률이 높을수록 압축/해제 연산이 복잡해져 접근 속도가 저하될 수 있다.

​
\- 압축률이 높을수록 데이터 크기는 감소하고 따라서 한 번에 많은 데이터를 읽을 수 있다. 하지만 압축과 압축 해제 작업에서 더 많은 RAM 과 CPU 싸이클을 사용한다. 

​
\- 일반적으로 데이터셋이 클수록 작은 압축 단위가 적합하다.

​
\- 일반적으로 압축 단위가 클수록 중복 데이터를 더 많이 포착할 수 있어 압축률이 향상될 가능성이 높다.

​
\- 압축 단위 : 압축 알고리즘이 한 번에 처리하는 데이터 크기. 

​
\- 압축 라이브러리 선택 시 고려 사항 : 메모리 오버헤드, 압축률, 압축 성능, 압축 해제 성능. 

​
```
# 중복 제거
​
- 압축 알고리즘들은 대부분 중복된 정보를 찾아내서 짧은 코드로 치환한다. 
​
- 압축단위가 클수록 더 넓은 범위에서 중복된 내용을 검사할 수 있다. 
​
- 중복 제거를 많이 할 수록 전체적인 압축 크기가 작아진다. (압축률이 높아진다.)
​
```
</br>

## **\# 정리와 유지**
​
\- 데이터 무결성 유지와 공간 회수, 오버헤드 최소화, 페이지 정렬 등의 작업을 백그라운드에서 수행하면 시간을 절약할 수 있고, 삽입과 업데이트, 삭제 작업의 후처리 비용이 줄어든다. 

​
\- 탐색 경로를 따라 접근할 수 있는 데이터를 live 상태라고 하고, 탐색 경로에서 제거되어 더 이상 참조되지 않는 데이터를 가비지(garbage) 라고 한다. 

</br>

​
## **\# 업데이트와 삭제로 인한 단편화**
​
\- 삭제 : 페이지 내부의 실제 데이터는 지우지 않고, 오프셋 테이블에서 삭제할 셀에 대한 포인터만 제거한다. 

​
\- 페이지 분할 : 분할되기 전 페이지의 오프셋 테이블은 무효화되고, 분할된 각 페이지에 맞게 오프셋 테이블을 새로 구성한다.  
</br>

​
\- 일부 데이터베이스는 삭제 또는 업데이트된 셀을 멀티버전 동시성 제어를 위해 바로 삭제하지 않는다.

​
\- 어떤 트랜잭션도 해당 셀을 사용하지 않을 때 가비지 컬렉션을 통해 셀을 정리한다. 

​
\- 일부 데이터베이스는 고스트(ghost) 레코드를 관리하는 자료 구조를 유지하면서 고스트 레코드에 접근하는 모든 트랜잭션이 완료되면 레코드를 정리한다. 

</br>

​
\- 삭제된 셀을 물리적으로 삭제하지 않고 오프셋만 삭제하면 단편화 문제가 발생할 수 있다.

​
\- 단편화된 여러 조각들을 모아 '연속된' 공간을 확보하려면 페이지를 재구성해야 한다. 

</br>

​
\- 삽입 작업은 튜플을 삽입 순서대로 저장한다. 

​
\- 튜플을 논리적 순서대로 저장하면 캐시를 프리페치해 순차 읽기에 도움이 될 수 있다. 

</br>

​
\- 대부분의 업데이트 작업은 리프 레벨에서 수행된다. 

​
\- 업데이트 작업은 키 단위로 수행되며, 오버플로우 페이지 생성 이외의 트리의 구조를 변경하는 작업은 하지 않는다.

​
\- 리프 노드 업데이트 시, 페이지 재구성을 최소화하기 위하여 셀의 순서는 변경하지 않는다. 

​
\- 셀을 업데이트할 때 기존 셀은 삭제하지 않고, 새로운 버전의 셀만 페이지의 빈공간에 삽입한 다음 오프셋 테이블에 새로운 버전의 셀에 대한 오프셋을 추가한다. 그리고 기존 셀에 대한 오프셋은 오프셋 테이블에서 삭제한다. 

</br>

​
## **\# 페이지 단편화**
​
\- 공간 회수 및 페이지를 재구성하는 작업을 컴팩션/정리/유지보수 라고 한다. 

​
\- 컴팩션과 쓰기를 동시에 수행할 수도 있지만, 일반적으로는 비동기적으로 이루어진다. 

</br>

​
\- 컴팩션은 데드 셀이 차지하는 공간을 회수하고 논리적 순서로 재정렬한다. 

​
\- 재구성된 페이지는 파일 내에서 위치가 바뀔 수 있다. 

​
\- 사용 중이지 않고 더티가 아닌 인메모리 페이지는 버퍼 풀에서 사용 가능 상태로 전환되어, 재사용 가능한 버퍼 슬롯(버퍼 풀 안에 존재하는 메모리 상의 빈 공간) 으로 반환된다. 
(더티 페이지인 경우 디스크에 플러시한 후, 사용 가능 상태로 전환되어 재사용 가능한 버퍼 슬롯으로 반환된다.)
​

\- 디스크에 새로 할당된 페이지의 ID 는 프리 페이지 목록(free page list, freelist) 에 추가된다. 

​
\*\* freelist : 디스크 상의 빈 페이지 목록 \*\*