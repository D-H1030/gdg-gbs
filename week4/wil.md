# 고급 백엔드 스터디 4주차 : 파일 포맷 (1)
## 3장 _ 파일 포맷

### 블록 & 페이지 

: 디스크의 I/O 단위가 블록이고, 블록이 메모리 위의 버퍼에 올라오면 페이지라고 부른다.

- 데이터를 메모리에 저장하면 레이아웃과 관련해서 특별한 설계가 따로 필요 없다. 설계를 하는 경우는 보통 최적화를 위한 경우이다. 
- 인메모리 기반 자료 구조보다 디스크 기반 자료 구조의 경우 신경 써야 할 사항들이 더 많다. 
- 디스크에 저장된 데이터에 접근하기 위해서는 대상 데이터의 오프셋을 직접 지정해야 한다.
- 디스크에 데이터를 쓸 때는 read 함수를 사용하고, 디스크에서 데이터를 읽어올 때는 write 함수를 사용한다.  

</br>

### endianess : 바이트 배열 순서

- 데이터를 인코딩하거나 디코딩할 때는 동일한 엔디언을 사용해야 한다.

1) 빅 엔디언(big endian) : 최상위 비트(MSB) 를 가장 낮은 주소에 저장.

2) 리틀 엔디언(little endian) : 최하위 비트(LSB) 를 가장 낮은 주소에 저장.

레코드는 디스크에 써지기 전에 '직렬화' 되고, 디스크에서 읽어지기 전에 '역직렬화' 된다.

### 직렬화 : 레코드를 바이트 시퀀스로의 변환

### 역직렬화 : 바이트 시퀀스를 원래의 레코드 형태로 변환

### 부동소수점의 직렬화 

: IEEE 754 방식을 따른다. 

구성 : 부호비트, exponent = 지수 + bias, fraction = 소수점 아래부분

1) single precision (총 32 bits)

- 형식 

부호비트(1) | Exponent (8) | Fraction (23)

- bias = 127

2) double precision (총 64 bits)

- 형식

부호비트(1) | Exponent (11) | Fraction (52)

- bias = 1023

### 문자열의 직렬화 

1) 파스칼 문자열(UCSD 문자열) : 길이 + 데이터(문자열) 형태로 문자열을 직렬화한다.

2) 널 종단 문자열(null terminated) : 데이터(문자열) + \0(널문자) 형태로 문자열을 직렬화한다. 

- 파스칼 문자열의 경우에는 표현된 길이만큼 문자열을 띡 읽으면 되고, 널 종단 문자열의 경우에는 널문자가 나올 때까지 읽는다.

### boolean 의 직렬화

: true = 1, false = 0 

- 불리언 값을 묶어 쓰기도 한다. 

### 열거형(Enum) 의 직렬화

: 숫자로 표현한다.

### 플래그형의 직렬화

> #### 플래그 : 묶음형 불리언과 열거형의 조합. 여러 개의 참/거짓 값을 한 번에 저장하고 표현할 수 있다. 각 상태에 한 비트가 할당된다.

- 동시에 일어날 수 있는 옵션 같은 걸 표현할 때 사용한다. 
- 모든 비트가 플래그이기 때문에 2의 거듭제곱만 지정 가능하다. (2의 거듭제곱의 이진수는 한 비트만이 1이기 때문)

### 파일 포맷 

- 일반적으로 파일 포맷 설계 시 '주소 지정 방식' 부터 결정해야 한다. 
- 대부분의 인플레이스 업데이트 방식을 지원하는 자료 구조는 고정된 페이지 크기를 사용한다. 크기가 고정된 페이지를 사용하는 경우 읽고 쓰기가 쉽다. 

 > #### 인플레이스(in-place) 업데이트 vs. 아웃 오브 플레이스(out-of-place) 업데이트
> : 인플레이스 업데이트는 기존 데이터를 다른 위치로 복사하지 않고, 그 자리에 새 값을 덮어쓰는 형태의 업데이트이다. </br>
> : 아웃 오브 플레이스 업데이트는 기존 데이터는 기존 위치에 둔 다음 새로운 데이터를 새로운 위치에 작성하고, 포인터가 새 데이터를 가리키도록 하는 형태의 업데이트이다. 

- 디스크 기반 데이터베이스에서는 일단 기본 작업은 읽고 쓰는 속도가 빠른 메모리에서 이루어진다. 이때 메모리 상의 버퍼에 페이지들을 임시로 저장하고, 버퍼가 감당할 수 있는 양을 넘어서면 버퍼에 있는 페이지를 디스크로 flush(밀어넣다) 한다. 

### 파일의 구조

: 헤더(고정크기) | 페이지들 | 트레일러(고정크기)

- 트레일러에는 오프셋 정보, 파일이 제대로 닫혀 있는 지 확인하는 정보, 파일 손상 여부를 확인하는 정보, 파일의 해석 방식에 대한 정보 등이 포함된다. 
- 헤더에는 엔디안 정보, 압축 여부에 대한 정보, 인코딩 정보, 파일의 형식과 구조를 해석하는 정보(파일 포맷), 파일 포맷 버전, 스키마 정보(어떤 필드가 어떤 타입으로 저장되는지) 등이 포함된다. 
- 파일의 나머지 부분은 페이지로 나누어져 저장된다. 

> #### 파일 구조의 계층적 저장 단위 
> 1) region : 전체 파일을 물리적/논리적으로 나눈 큰 구획.
> 2) section : region 내부를 더 세분화한 단위. 
> 3) page : 고정 크기의 저장 단위 
> 4) cell : 페이지 안의 하나의 레코드. 테이블의 한 행에 해당한다.
> 5) field : cell 내부의 각각의 속성.
> 6) primitive type (기본형) : int, float, char 같은 실제 데이터 값의 타입.

- 파일 포맷을 설계하는데 반드시 따라야 하는 규칙은 없다. 

### 가변 길이 레코드를 저장하는 방법 중 하나, 슬롯 페이지

- 페이지 내부를 실제 레코드 내용을 저장하는 **셀** 부분과 셀에 대한 위치 정보(오프셋)를 담고 있는 **슬롯** 부분으로 나눈다. 이런식의 페이지 구조를 슬롯 페이지라고 한다. 

- 슬롯 페이지 구조에서는 슬롯들이 저장되어 있는 **slot directory** 가 존재하고, 헤더와 slot directory 를 제외한 페이지의 나머지 부분에 셀이 위치한다. 
- 슬롯 페이지 방식의 경우 슬롯 디렉토리를 보고 셀의 위치를 알 수 있으므로 가변 길이 레코드를 저장할 수 있다. 
- 셀을 삭제하거나 삽입하고 싶으면 슬롯을 제거하거나 추가하면 된다. (페이지는 고정 크기이기 때문에, 만약 페이지가 꽉 차면 그냥 슬롯과 셀을 추가할 수는 없고 다음 페이지에 삽입하거나 페이지를 분할하거나 한다고 한다)

### 셀 구조

(여기서 말하는 셀은 위에서 말한 슬롯 페이지 내부의 셀과는 다른 의미. 인덱스 페이지 내부의 키 + 포인터로 구성된 요소.) 

- 셀의 종류

1) **키 셀** : 셀에는 구분 키와 인접한 두 키 사이의 페이지를 가리키는 포인터가 들어있다. 

2) **키 - 값 셀** : 셀에는 키와 해당 키의 데이터 레코드가 들어있다. 

- 키 셀의 구성 요소

1) 셀의 종류

2) 키 길이

3) 셀이 가리키는 자식 페이지의 ID

4) 키 바이트 수

> .. 여기서 '키 길이' 와 '키 바이트 수' 가 동일한 거 아닌가..? 하는 의문이 들어서 찾아보니, 키 길이는 글자 수의 개념이고, 키 바이트 수는 그 글자가 차지하는 총 바이트 수로 둘은 다른 개념이었다. 

- 키-값 셀의 구성 요소

1) 셀의 종류

2) 키 길이

3) 값 길이

4) 키 바이트

5) 데이터 레코드 바이트

### 셀 병합으로 슬롯 페이지 구성 

- 셀은 삽입 순서대로 배치되고, 오프셋(포인터)는 이진탐색이 가능하도록 정렬되어 배치된다.
