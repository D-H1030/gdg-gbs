# 고급 백엔드 스터디 3주차 : B-tree

```
# in - place 업데이트

: 데이터를 업데이트할 때, 기존의 위치에 새 데이터를 덮어쓰는 방식.
```

</br>

# \# 이진 탐색 트리 (BST, Binary Search Tree)

- 데이터를 디스크가 아니라 메모리에 올려두고 사용하는 자료 구조 (= 인메모리 자료 구조)
- 각 노드는 최대 두 개의 자식 노드를 가질 수 있다.
- 각 노드는 키와 값과 두 개의 자식을 가리키는 포인터를 가진다.
- 키는 탐색과 정렬의 기준이다.
- 각 노드의 키는 왼쪽 서브트리의 모든 노드의 키보다는 크고, 오른쪽 서브트리의 모든 노드의 키보다는 작다.
- 탐색은 루트 노드부터 시작된다. 리프 노드까지 도달하기 전에 탐색 대상을 찾으면 탐색은 멈춘다.
- 균형잡힌 이진 탐색 트리의 탐색 시간 복잡도는 O(log n) 이다. (n : 노드의 개수)
- 이진 탐색 트리의 탐색 효율을 위해 트리의 균형을 유지하는 것이 중요하다.
- 트리의 균형을 유지하는 법 한 가지 : 트리 회전
- 이진 탐색 트리는 팬아웃이 2로 작기 때문에, 트리 밸런싱과 노드 재배치, 포인터 갱신이 자주 발생하므로 유지 비용 측면에서 디스크 기반 자료 구조로는 적합하지 않다.

</br>


```
# fanout

: 노드가 가질 수 있는 최대 자식 노드의 개수를 말한다.
```

</br>

# \# 2-3 tree

- 트리의 내부노드가 2-node 이거나 3-node 인 트리.
- 2-node : 1개의 키를 가지고, 2개의 자식 노드(포인터)를 가지는 노드.
  3-node : 2개의 키를 가지고, 3개의 자식 노드(포인터)를 가지는 노드.
- 노드의 종류
  1) Internal node (내부노드) : 키를 가지는 노드.
  2) Leaf node : 자식이 없는 노드.
  3) External node (외부노드) : 데이터가 들어있지 않은 가상의 노드로, leaf node의 자식 노드이다. 모든 외부노드는 같은 레벨에 있고, 트리높이 +1의 위치에 존재한다.

---

</br>
디스크 기반 트리를 설계할 때는, 디스크의 탐색 횟수를 고려하여 지역성을 갖춘 자료 구조를 선택해야 한다.


</br>


# \# 디스크 기반 트리의 특성

1) 인접한 키의 지역성을 높이기 위한 높은 팬아웃. (팬아웃이 높으면 자식 수가 증가하고, 그에 따라 한 노드에 저장되는 키의 수가 증가하고, 노드 하나를 디스크에 저장할 때 그 키들이 같은 페이지에 저장되게 돼서 지역성이 증가한다.)
2) 낮은 높이 (트리의 높이가 낮으면, 트리 순회 중 디스크 탐색 횟수가 줄어든다.)

</br>

** 팬아웃과 트리의 높이는 반비례한다. **

</br>

```
# 노드의 키와 포인터

: 키는 범위를 구분하는 경계이고, 포인터는 특정 키 구간에 해당하는 자식 노드를 가리킨다.
```


</br>

메모리에 모든 데이터를 저장할 수 없기 때문에 \'디스크 기반의 자료 구조\'가 필요하다.

</br>



# \# HDD (Hard Disk Drive)

- 디스크를 회전 시켜 특정 위치에 헤드를 옮기고, 디스크 위 섹터의 자화 상태를 바꾸어 데이터를 쓴다.
- 데이터를 다루는 최소 단위를 sector 라고 한다. 모든 작업은 최소 한 개의 섹터를 읽거나 쓴다. (섹터의 크기는 보통 512바이트에서 4Kb 사이)
- HDD 는 헤드를 이동시켜 데이터를 읽는데, 헤드 이동에 비용이 많이 든다. 따라서 연속된 섹터를 읽거나 쓰는 것이 비용을 줄이는 방법이다.

</br>

# \# SSD (Solid State Drive)

- 디스크와 헤드가 없다.
- 메모리 cell 로 구성된다. (내부 구현 방식에 따라 셀은 한 개 또는 여러 개의 비트를 저장한다.)
  (셀 < 스트링 < 페이지 < 블록 < 플레인 < 다이)
- SSD 는 한 개 이상의 다이로 이루어진다.
- SSD 에서 읽고 쓰는 최소 단위는 페이지이고, 비어있는 페이지에만 쓰기가 가능하다. (덮어쓰기는 불가능)
- SSD 에서 삭제할 수 있는 최소 단위는 블록이다.
- 블록 내 페이지는 일반적으로 순차적으로 쓰이지만, SSD 컨트롤러가 상황에 따라 동적으로 페이지를 할당할 수 있다.

</br>

# \# Flash Translation Layer (FTL)

: 페이지 ID를 실제 물리적 위치와 매핑하고, 비어 있거나 쓰여진 페이지를 관리하는 논리 계층이며, 플래시 메모리 컨트롤러 내부에 구현된다.
- 가비지 컬렉션을 수행한다. 놀고 있는 페이지를 관리하는 역할을 한다.



```
# 플래시 메모리

: 하드 디스크처럼 회전하는 디스크가 없고, 전자회로로만 데이터를 저장, 읽기, 삭제를 하는 메모리이다.

# 플래시 드라이브

: 플래시 메모리를 이용해 데이터를 저장하는 비휘발성 저장 장치이다.
```
</br>

** 운영체제는 HDD와 SSD 같은 블록 디바이스의 데이터를 읽고 쓸 때, '블록' 단위로 작업한다. **

</br>

# \# 디스크 기반 자료 구조

- 디스크의 접근 최소 단위가 블록이라는 제약은 디스크 기반 자료 구조의 설계를 어렵게 하는 요소 중 하나이다.
- 대부분의 디스크 기반 자료 구조의 경우 포인터를 직접 관리해야 한다.
- 자료 구조가 복잡해지지 않고, 유지 관리가 어려워지지 않도록 포인터의 개수를 최소화하는 것이 좋다.
  (포인터 사용에는 오버헤드가 발생한다.)
- 디스크 기반 자료 구조는 디스크 접근 횟수를 최소화 할 수 있는 형태여야 한다.

</br> 

# \# B-tree

- B-tree: 최대 자식 노드의 수가 2보다 큰 트리.
- 최대 M개의 자식을 가질 수 있는 B-트리를 M차 B-트리라고 한다.
- B-tree 는 키의 순서가 보장되는 자료 구조로, 노드의 키는 정렬되어 저장된다.
- 페이지 기반의 자료 구조로, 고정 크기 페이지 단위로 노드를 탐색하고 구성한다.

- 각 노드는 최대 n개의 키를 가지고, n+1개의 자식 노드 포인터를 가진다.

- 노드의 분류
  1. 루트 노드
  2. 내부 노드
  3. 리프 노드 : 모든 리프 노드의 레벨은 같다.

- 점유율 = 실제 보유하고 있는 키의 개수 / 보유 가능한 노드의 개수
- 팬아웃이 높으면, 하나의 블록에 여러 키와 자식 포인터를 저장할 수 있으므로 탐색 시 실퍼어야 할 블록 수가 줄어들어 탐색 비용이 감소한다.

</br>

# \# B+ tree

- B+ tree 는 값을 리프 노드에만 저장하고, 루트 노드와 내부 노드에는 리프 노드까지 도달하기 위한 구분 키만 저장한다.

</br>

** 일반적으로 B+ 트리를 그냥 B 트리라고 부른다. **

</br>

- 리프 노드가 많아질수록 내부 노드의 개수와 트리의 높이가 증가한다.
- 탐색 시간 복잡도 : log M (M : 전체 노드의 개수)

</br>


# \# B 트리의 탐색, 삽입, 삭제

- 탐색 : 하향식(루트 노드부터 시작해서 찾고자 하는 키를 찾는다.)

- 삽입 : 상향식(새로운 키-값을 삽입할 리프 노드를 찾고 삽입한다.)

** B 트리의 노드 분할 : 노드가 가질 수 있는 키의 개수를 넘어가게 되면 노드를 분할해야 한다. **

1) 키 삽입으로 인한 리프 노드의 분할 : 승급된 분할 지점의 키를 부모 노드에 복사하고, 승급된 키를 포함하여 승급된 키 이후의 키와 값을 새로운 노드에 저장한다. 새로운 키는 구분 키의 속성에 따라 기존 노드와 새로운 노드 중 올바른 노드에 삽입된다. 부모 노드의 포인터 수가 하나 증가한다.

2) 키 삽입으로 인한 비 리프 노드의 분할 : 승급된 분할 지점의 키를 부모 노드로 이동시키고, 승급된 키 이후의 키들을 새로운 노드에 저장한다. 새로운 키는 구분 키의 속성에 따라 기존 노드와 새로운 노드 중 올바른 노드에 삽입된다. 부모 노드의 포인터 수가 하나 증가한다.

- 삭제 : 삭제할 키가 포함된 리프 노드를 찾아서 키와 값을 삭제한다.

** B 트리의 노드 병합 : 노드가 가질 수 있는 키의 개수보다 노드가 가지고 있는 키의 개수가 한참 적으면 노드를 병합해야 한다. **

1) 리프 노드의 병합 : 부모 노드의 구분 키를 삭제하고, 한 쪽 노드의 키-값 쌍을 다른 쪽으로 옮긴다. 부모 노드의 포인터 수가 하나 감소한다.

2) 비 리프 노드의 병합 : 부모 노드의 구 키를 한 쪽 노드로 가져오면서 노드를 병합한다. 부모 노드의 포인터 수가 하나 감소한다.

</br>

일반적으로 병합 시, 오른쪽 노드에서 왼쪽 노드로 키를 옮기지만, 키의 순서만 보장된다면 반대로 옮겨도 상관없다.

</br>

** 노드의 분할과 병합은 트리의 전체적인 균형을 유지하기 위함이다. **
