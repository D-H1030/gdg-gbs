# 고급 백엔드 스터디 5주차  

### 가변 길이 데이터 관리

: 페이지를 삭제할 때, 삭제된 페이지가 차지하고 있던 셀의 공간을 다른 셀로 채울 필요는 없다.  
: 그냥 삭제된 셀이라고 표시하고, 메모리에 저장된 사용 가능 목록(availability list) 에 회수된 메모리의 크기와  
해당 위치를 가리키는 포인터를 업데이트해도 된다.  

</br>

### 페이지 내의 빈 세그먼트 선택 방법

1) 최초 적합(First fit) : 첫번째로 찾은 적합한 세그먼트를 선택한다.  
(... 여기서, 적합하다는 말의 의미는 레코드의 크기보다 세그먼트의 크기가 커서 레코드 전부가 저장될 수 있음을 의미한다.)  

장점 : 간단하고 동작이 빠르며 내부단편화를 줄일 수 (레코드가 들어갈 수 있는 칸을 차례로 채워나가기 때문) 있다.  
단점 : 외부단편화가 생길 수 있다.  


2) 최적 적합(Best fit) : 레코드를 저장할 수 있는 가장 작은 세그먼트를 선택한다.  

장점 : 외부단편화를 줄일 수 있다.  

단점 : 가장 최적의 공간을 찾기 위해, 모든 공간을 살펴봐야 한다. 세그먼트 할당 과정이 느리고 복잡하다.  

</br>

... 페이지에 레코드를 저장하는 과정에서는 내부 단편화와 외부 단편화가 발생할 수 밖에 없다.  

외부 단편화가 발생하여 페이지 내에 추가적인 레코드를 저장할 연속적인 공간이 없는 경우에는  
모든 셀을 읽고 재배치해 외부 단편화를 제거한 뒤, 새 레코드를 저장할 수도 있다.  

하지만 단편화를 제거했는데도 페이지 내에 새 레코드를 저장할 공간이 없다면, 오버플로우 페이지를 생성해야 한다.  

(... 오버플로우 페이지는 기존 페이지와 연결되는 보조적인 페이지라고 생각하면 된다. 기존 페이지에 존재하는 포인터를 통해  
오버플로우 페이지와 연결된다.)

</br>

### 버전 관리

: 데이터베이스 시스템을 업데이트 하는 과정에서 바이너리 파일의 구조가 변경될 수 있다.  
: 일반적으로 스토리지 엔진은 한 개 이상의 직렬화 포맷을 지원한다.  
(... 여기서 직렬화 포맷은 DBMS가 자신의 내부 데이터를 디스크에 저장하기 위해 사용하는 포맷을 말한다.)

```
 ... 여기서 말하는 바이너리 파일의 의미

: 사용자가 데이터베이스에 데이터를 저장할 때, 그 데이터는 단순히 사람이 읽을 수 있는 텍스트나 구조 그대로  저장되는 것이 아니라, DBMS가 정의한 직렬화 포맷에 따라 구조화된 바이너리 파일로 변환되어 저장된다. 

: DBMS 가 업데이트 되어서 버전이 바뀌면 DBMS 가 내부적으로 사용하는 바이너리 파일들의 구조가 달라져서, 기존 버전의 바이너리 파일들이 새 버전의 DBMS와 호환이 되지 않을 수 있고, 이런 문제를 방지하기 위해 DBMS 에서 여러 버전의 파일 직렬화 포맷을 지원하는 것이다.  
(이렇게 되면 새 버전의 DBMS 가 이전 버전의 바이너리 파일을 내부적으로 사용할 수 있게 된다.)
```
- 바이너리 파일 버전 확인 방법 : 파일명에 버전을 의미하는 접두사를 붙이거나, 파일 버전 정보를 저장해 놓은 개별 파일을 확인할 수도 있다.  
인덱스 파일 헤더에 버전을 명시할 수도 있다.

</br>

### 파일 오류 체크

1) 체크섬(checksum)  
2) CRC (Cyclic Redundancy Check)

``` 
# CRC 

- 원래 데이터 (16진수)

- polynomial : 다항식 형태 (예 : x^9 + x^6 + 1)


1. 16진수 데이터를 2진수로 바꾼다.

2. polynomial 의 각 항의 계수 (0 아니면 1) 을 모아서 2진수를 만든다.

3. 원래 데이터에 polynomial 의 차수만큼의 0 을 뒤에 덧붙인다.

4. 3. 과 2. 에 대해서 bitwise xor 연산을 수행한다.  
5. 4. 를 한 번 수행한 뒤, 2.의 값을 오른쪽으로 한 칸 쉬프트 한 뒤 bitwise xor 연산을 다시 수행한다.  

6. 5를 반복한다. (만약 2. 값을 오른쪽으로 한 칸 쉬프트 했을 때, 그 수의 맨 앞자리 값과 대응되는 3. 의 값이 0이면  
bitwise xor 연산을 수행하지 않고 2. 의 값을 오른쪽으로 한 칸 쉬프트 한다.)  


원래 데이터에 덧붙였던 0 자리의 값들이 다른 값들로 채워질 때까지 5를 반복하고, 그렇게 0의 자리에 채워진 값들이  
CRC 가 된다.  


원래 데이터에 CRC 를 덧붙여서 데이터를 송신하면, 수신자는 받은 데이터에 대해 CRC 를 수행하고 CRC 자리가 모두  
0이 나오면 데이터의 손상이 없는 것으로 판단한다.
